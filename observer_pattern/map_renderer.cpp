// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

#include "geometry.h"
#include <iostream>
#include <list>

/**
 * Interface for map_renderers that render geo data.
 */
template <typename T> class map_renderer {
public:
  using GeoData = T;

  /**
   * Render geo data and add details to a map.
   */
  virtual void render(GeoData data) = 0;
  virtual ~map_renderer() = default;
};

/**
 * Render paths into a map.
 */
template <typename T> class path_map_renderer : public map_renderer<T> {
public:
  using GeoData = typename map_renderer<T>::GeoData;
  void render(GeoData data) {
    //    std::cout << "Render path"
    //              << "\n";
  }
};

/**
 * Render fields into a map.
 */
template <typename T> class field_map_renderer : public map_renderer<T> {
public:
  using GeoData = typename map_renderer<T>::GeoData;
  void render(GeoData data) {
    //    std::cout << "Render field"
    //              << "\n";
  }
};

/**
 * Interface for provider of geo data.
 */
template <typename T> class geo_data_provider {
public:
  using GeoData = T;

  /**
   * Register a map renderer to receive geo data.
   */
  virtual void register_map_renderer(map_renderer<GeoData> *renderer) = 0;

  /**
   * Unregister a map renderer to receive geo data.
   */
  virtual void unregister_map_renderer(map_renderer<GeoData> *renderer) = 0;

  /**
   * Send geo data to all registered observers.
   */
  virtual void send_geo_data(GeoData data) = 0;
  virtual ~geo_data_provider() = default;
};

/**
 * Provide geo data generated by an ECU.
 */
template <typename T>
class ecu_geo_data_provider : public geo_data_provider<T> {
public:
  using GeoData = typename geo_data_provider<T>::GeoData;

  void register_map_renderer(map_renderer<GeoData> *renderer) override {
    map_renderers_.push_back(renderer);
  }

  void unregister_map_renderer(map_renderer<GeoData> *renderer) override {
    map_renderers_.remove(renderer);
  }

  void send_geo_data(GeoData data) override {
    for (const auto renderer : map_renderers_) {
      renderer->render(data);
    }
  }

private:
  using RendererContainer = std::list<map_renderer<GeoData> *>;
  RendererContainer map_renderers_;
};

int main(int argc, char *argv[]) {
  ecu_geo_data_provider<ring> provider;

  map_renderer<ring> *path_renderer = new path_map_renderer<ring>();
  map_renderer<ring> *field_renderer = new field_map_renderer<ring>();

  provider.register_map_renderer(path_renderer);
  provider.register_map_renderer(field_renderer);

  point a{0.0, 0.0};
  point b{0.0, 5.0};
  point c{5.0, 5.0};
  point d{5.0, 0.0};
  line path{a, b};
  ring field{a, b, c, d, a};

  for (int i = 0; i < 100000000; ++i) {
    provider.send_geo_data(field);
  }

  provider.unregister_map_renderer(path_renderer);
  provider.send_geo_data(field);
  provider.unregister_map_renderer(field_renderer);

  return 0;
}
